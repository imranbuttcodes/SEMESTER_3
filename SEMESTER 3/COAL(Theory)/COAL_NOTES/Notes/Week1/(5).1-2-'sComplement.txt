Perfect ğŸ‘Œ letâ€™s build this step by step.

We already know **Sign-Magnitude** (MSB is sign, rest is magnitude). Now letâ€™s see how **1â€™s complement** and **2â€™s complement** work.

---

# ğŸ”¹ 1â€™s Complement Representation

ğŸ‘‰ Rule:
To represent a **negative number**, take the binary of the positive number and **flip all the bits** (0 â†’ 1, 1 â†’ 0).

* Positive numbers: same as normal binary.
* Negative numbers: bitwise inversion of the positive.

### Example: +13 and -13 (8-bit)

* +13 = `00001101`
* -13 = invert all bits â†’ `11110010`

âœ… So in 1â€™s complement:

* +13 = `00001101`
* -13 = `11110010`

âš ï¸ Problem: Still has **two zeros**:

* +0 = `00000000`
* -0 = `11111111`

---

# ğŸ”¹ 2â€™s Complement Representation

ğŸ‘‰ Rule:
To represent a **negative number**:

1. Write positive number in binary.
2. Take 1â€™s complement (flip bits).
3. Add **1** to the result.

* Positive numbers: same as normal binary.
* Negative numbers: (invert + add 1).

### Example: +13 and -13 (8-bit)

* +13 = `00001101`
* To get -13:

  * Start with `00001101`
  * 1â€™s complement = `11110010`
  * Add 1 = `11110011`

âœ… So in 2â€™s complement:

* +13 = `00001101`
* -13 = `11110011`

---

# ğŸ”¹ Why 2â€™s Complement is the Winner?

* Only **one zero** (no +0 / -0 confusion).
* Arithmetic (addition/subtraction) works naturally in hardware.
* This is what **modern CPUs actually use**.

---

âœ… Quick Check for You:
Can you represent **-45** in both:

1. **1â€™s complement (8-bit)**
2. **2â€™s complement (8-bit)**

Try step by step â€” write +45 first, then convert.
