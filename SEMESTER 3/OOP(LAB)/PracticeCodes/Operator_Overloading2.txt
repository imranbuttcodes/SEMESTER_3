ğŸ”¥ Excellent â€” now youâ€™re moving into the **next level** of operator overloading:
ğŸ‘‰ *mixed-type operator overloading*, where one side is an object and the other is a built-in type (like `int`).

Letâ€™s carefully break down **why your line doesnâ€™t work yet** and how to make it work â€” step by step.

---

## ğŸ§© You wrote:

```cpp
Thing three = one + 10;
```

Letâ€™s think like the compiler.
It sees:

* Left side: `Thing` (user-defined type)
* Right side: `int` (built-in type)

Then it tries to find a matching function for `operator+`.

---

### ğŸ§  Step 1 â€” Your current definition

```cpp
Thing operator+(Thing obj);
```

This expects the **right-hand side** to be a **Thing**, not an `int`.

So the compiler looks for a constructor that could convert `int` â†’ `Thing`.

You *do* have:

```cpp
Thing(int x);
```

That means `int` **can be implicitly converted** to `Thing`.

âœ… So C++ can **construct a temporary `Thing(10)`** automatically.

Thus, this line:

```cpp
Thing three = one + 10;
```

becomes:

```cpp
Thing three = one.operator+( Thing(10) );
```

So yes â€” it **actually works already**, thanks to **implicit constructor conversion** ğŸ‰

---

### ğŸ§© Step 2 â€” But what if we want to handle both directions?

The problem appears if you reverse the operands:

```cpp
Thing three = 10 + one;   // âŒ won't compile
```

Why?

Because the compiler tries:

```cpp
10.operator+(one);  // invalid â€” 10 is an int, not a Thing
```

The left operand determines which operator function is looked up.
Since `10` is an `int`, it canâ€™t call `Thing::operator+`.

---

## ğŸ§  Step 3 â€” How to fix that (make both sides work)

You can define a **non-member (friend) operator function**:

```cpp
class Thing {
public:
    int x;
    Thing(int x): x(x) {}
    
    Thing operator+(const Thing& other) const {
        cout << "Member operator+\n";
        return Thing(this->x + other.x);
    }

    // Friend version to handle (int + Thing)
    friend Thing operator+(int lhs, const Thing& rhs);
};

// outside the class
Thing operator+(int lhs, const Thing& rhs) {
    cout << "Non-member operator+\n";
    return Thing(lhs + rhs.x);
}
```

---

## ğŸ§ª Now both will work:

```cpp
Thing one(5);

Thing three = one + 10;  // uses member operator+
Thing four  = 10 + one;  // uses non-member operator+
```

Output:

```
Member operator+
Non-member operator+
```

---

## ğŸ’¡ Step 4 â€” Summary of how the compiler resolves it

| Expression  | Compiler Looks For                                   | Result                    |
| ----------- | ---------------------------------------------------- | ------------------------- |
| `one + 10`  | `Thing::operator+(int)` or `Thing::operator+(Thing)` | âœ… works (via constructor) |
| `10 + one`  | global `operator+(int, Thing)`                       | âœ… works if defined        |
| `one + two` | `Thing::operator+(Thing)`                            | âœ… works                   |

---

## ğŸ§¬ Step 5 â€” Optional: make it cleaner with implicit conversion

If you mark your constructor as `explicit`, like:

```cpp
explicit Thing(int x);
```

then `one + 10` will **stop working automatically**, because implicit conversion will be disallowed.

So:

* **Without `explicit` â†’** `int` can auto-convert to `Thing`
* **With `explicit` â†’** you must explicitly say `Thing(10)`

---

âœ… **Final summary:**

| Case                               | Works?                                          | Why |
| ---------------------------------- | ----------------------------------------------- | --- |
| `one + 10`                         | âœ… Yes (int â†’ Thing via constructor)             |     |
| `10 + one`                         | âŒ unless you add global `operator+(int, Thing)` |     |
| `Thing one(5); one + two;`         | âœ… standard member overload                      |     |
| `explicit Thing(int)` + `one + 10` | âŒ prevents implicit conversion                  |     |

---

